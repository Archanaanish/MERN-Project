{"ast":null,"code":"'use strict';\n\nconst arrayAtomicsSymbol = require('../helpers/symbols').arrayAtomicsSymbol;\n\nconst sessionNewDocuments = require('../helpers/symbols').sessionNewDocuments;\n\nmodule.exports = function trackTransaction(schema) {\n  schema.pre('save', function () {\n    const session = this.$session();\n\n    if (session == null) {\n      return;\n    }\n\n    if (session.transaction == null || session[sessionNewDocuments] == null) {\n      return;\n    }\n\n    if (!session[sessionNewDocuments].has(this)) {\n      const initialState = {};\n\n      if (this.isNew) {\n        initialState.isNew = true;\n      }\n\n      if (this.schema.options.versionKey) {\n        initialState.versionKey = this.get(this.schema.options.versionKey);\n      }\n\n      initialState.modifiedPaths = new Set(Object.keys(this.$__.activePaths.states.modify));\n      initialState.atomics = _getAtomics(this);\n      session[sessionNewDocuments].set(this, initialState);\n    } else {\n      const state = session[sessionNewDocuments].get(this);\n\n      for (const path of Object.keys(this.$__.activePaths.states.modify)) {\n        state.modifiedPaths.add(path);\n      }\n\n      state.atomics = _getAtomics(this, state.atomics);\n    }\n  });\n};\n\nfunction _getAtomics(doc, previous) {\n  const pathToAtomics = new Map();\n  previous = previous || new Map();\n  const pathsToCheck = Object.keys(doc.$__.activePaths.init).concat(Object.keys(doc.$__.activePaths.modify));\n\n  for (const path of pathsToCheck) {\n    const val = doc.$__getValue(path);\n\n    if (val != null && val instanceof Array && val.isMongooseDocumentArray && val.length && val[arrayAtomicsSymbol] != null && Object.keys(val[arrayAtomicsSymbol]).length > 0) {\n      const existing = previous.get(path) || {};\n      pathToAtomics.set(path, mergeAtomics(existing, val[arrayAtomicsSymbol]));\n    }\n  }\n\n  const dirty = doc.$__dirty();\n\n  for (const dirt of dirty) {\n    const path = dirt.path;\n    const val = dirt.value;\n\n    if (val != null && val[arrayAtomicsSymbol] != null && Object.keys(val[arrayAtomicsSymbol]).length > 0) {\n      const existing = previous.get(path) || {};\n      pathToAtomics.set(path, mergeAtomics(existing, val[arrayAtomicsSymbol]));\n    }\n  }\n\n  return pathToAtomics;\n}\n\nfunction mergeAtomics(destination, source) {\n  destination = destination || {};\n\n  if (source.$pullAll != null) {\n    destination.$pullAll = (destination.$pullAll || []).concat(source.$pullAll);\n  }\n\n  if (source.$push != null) {\n    destination.$push = destination.$push || {};\n    destination.$push.$each = (destination.$push.$each || []).concat(source.$push.$each);\n  }\n\n  if (source.$addToSet != null) {\n    destination.$addToSet = (destination.$addToSet || []).concat(source.$addToSet);\n  }\n\n  if (source.$set != null) {\n    destination.$set = Object.assign(destination.$set || {}, source.$set);\n  }\n\n  return destination;\n}","map":{"version":3,"sources":["C:/Final Project/node_modules/mongoose/lib/plugins/trackTransaction.js"],"names":["arrayAtomicsSymbol","require","sessionNewDocuments","module","exports","trackTransaction","schema","pre","session","$session","transaction","has","initialState","isNew","options","versionKey","get","modifiedPaths","Set","Object","keys","$__","activePaths","states","modify","atomics","_getAtomics","set","state","path","add","doc","previous","pathToAtomics","Map","pathsToCheck","init","concat","val","$__getValue","Array","isMongooseDocumentArray","length","existing","mergeAtomics","dirty","$__dirty","dirt","value","destination","source","$pullAll","$push","$each","$addToSet","$set","assign"],"mappings":"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","sourcesContent":["'use strict';\n\nconst arrayAtomicsSymbol = require('../helpers/symbols').arrayAtomicsSymbol;\nconst sessionNewDocuments = require('../helpers/symbols').sessionNewDocuments;\n\nmodule.exports = function trackTransaction(schema) {\n  schema.pre('save', function() {\n    const session = this.$session();\n    if (session == null) {\n      return;\n    }\n    if (session.transaction == null || session[sessionNewDocuments] == null) {\n      return;\n    }\n\n    if (!session[sessionNewDocuments].has(this)) {\n      const initialState = {};\n      if (this.isNew) {\n        initialState.isNew = true;\n      }\n      if (this.schema.options.versionKey) {\n        initialState.versionKey = this.get(this.schema.options.versionKey);\n      }\n\n      initialState.modifiedPaths = new Set(Object.keys(this.$__.activePaths.states.modify));\n      initialState.atomics = _getAtomics(this);\n\n      session[sessionNewDocuments].set(this, initialState);\n    } else {\n      const state = session[sessionNewDocuments].get(this);\n\n      for (const path of Object.keys(this.$__.activePaths.states.modify)) {\n        state.modifiedPaths.add(path);\n      }\n      state.atomics = _getAtomics(this, state.atomics);\n    }\n  });\n};\n\nfunction _getAtomics(doc, previous) {\n  const pathToAtomics = new Map();\n  previous = previous || new Map();\n\n  const pathsToCheck = Object.keys(doc.$__.activePaths.init).concat(Object.keys(doc.$__.activePaths.modify));\n\n  for (const path of pathsToCheck) {\n    const val = doc.$__getValue(path);\n    if (val != null &&\n        val instanceof Array &&\n        val.isMongooseDocumentArray &&\n        val.length &&\n        val[arrayAtomicsSymbol] != null &&\n        Object.keys(val[arrayAtomicsSymbol]).length > 0) {\n      const existing = previous.get(path) || {};\n      pathToAtomics.set(path, mergeAtomics(existing, val[arrayAtomicsSymbol]));\n    }\n  }\n\n  const dirty = doc.$__dirty();\n  for (const dirt of dirty) {\n    const path = dirt.path;\n\n    const val = dirt.value;\n    if (val != null && val[arrayAtomicsSymbol] != null && Object.keys(val[arrayAtomicsSymbol]).length > 0) {\n      const existing = previous.get(path) || {};\n      pathToAtomics.set(path, mergeAtomics(existing, val[arrayAtomicsSymbol]));\n    }\n  }\n\n  return pathToAtomics;\n}\n\nfunction mergeAtomics(destination, source) {\n  destination = destination || {};\n\n  if (source.$pullAll != null) {\n    destination.$pullAll = (destination.$pullAll || []).concat(source.$pullAll);\n  }\n  if (source.$push != null) {\n    destination.$push = destination.$push || {};\n    destination.$push.$each = (destination.$push.$each || []).concat(source.$push.$each);\n  }\n  if (source.$addToSet != null) {\n    destination.$addToSet = (destination.$addToSet || []).concat(source.$addToSet);\n  }\n  if (source.$set != null) {\n    destination.$set = Object.assign(destination.$set || {}, source.$set);\n  }\n\n  return destination;\n}"]},"metadata":{},"sourceType":"script"}